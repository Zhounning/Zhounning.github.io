# 类加载

## 类加载子系统

* 类加载器子系统的作用

  类加载器子系统作用是负责从文件系统或者网络当中加载Class文件，class文件在文件开头有特定的文件标识。

* 加载的类信息最终存放在方法区当中

* 类加载的过程

  * 加载。加载主要做三件事，1、通过全类名获取定义此类的二进制字节流2、将字节流所代表的静态存储结构转换为方法区的运行时数据结构3、在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口
  * 链接
    * 验证。验证字节流中包含信息是否符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。验证包括文件格式验证，元数据验证，字节码验证，符号引用验证。
    * 准备。准备阶段时正式为类变量分配内存并且设置该变量的默认初始值（零值），这些内存都会在方法区中进行分配。特殊情况是当变量加上`final`进行修饰时，会在准备阶段
    * 解析。解析阶段是虚拟机将常量池内的符号应用替换为直接应用的过程。
  * 初始化。当我们的代码当中包含static变量的时候，就会有clinit方法，不需要自己定义编译器会自动将类中的所有类变量的赋值动作和静态代码块中的语句合并而来。另外初始化方法`()`是带锁的，目的是保证线程安全。

## 类加载器

JVM中内置了三个重要的ClassLoader，除了BootstrapClassLoader 其他类加载器均由java实现且全部继承自`java.lang.ClassLoader`

* **BootstrapClassLoader(启动类加载器)**，最顶层的加载类，由C++实现。
* **ExtensionClassLoader(扩展类加载器)**，主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
* **AppClassLoader(应用程序类加载器)** ，面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

## 双亲委派模型

双亲委派模型介绍。系统中的ClassLoder在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

好处：

* 避免类的重复加载
* 保护程序安全，防止核心API被随意篡改

