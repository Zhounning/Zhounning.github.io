1. HashMap在jdk1.7和jdk1.8中有那些不同？HashMap的底层实现

   简单来说HashMap是由链表和数组组合构成的数据结构，使用拉链法解决hash冲突。在java8之前，单纯使用的使用拉链法，拉链法是将数组和链表相结合，也就是说创建出一个链表数组，数组中的每一格都是一条链表，当发生哈希冲突的时候，直接增加冲突的值到链表当中即可。在java8之后，对链表做了一个小小的改动，当链表的长度大于8且数组长度大于64的时候，会将链表转化为红黑树，来优化查找值的时间。

   HashMap中jdk1.7和jdk1.8的不同，大概5点

   * 存储结构：jdk1.7采用数组+链表，jdk1.8采用数组+链表+红黑树
   * hash值计算：jdk1.7是9次扰动，4次位运算+5次异或运算；jdk1.8是2次扰动，1次位运算+1次异或运算
   * 存放规则：jdk1.7是无冲突时，存放数组；冲突时，存放链表；jdk1.8是无冲突时，存放数组；冲突 & 链表长度 < 8：存放单链表；冲突 & 链表长度 > 8且数组长达大于64：树化并存放红黑树
   * 插入数据方式：jdk1.7是头插法；jdk1.8尾插法
   * 扩容后存储位置的计算方式：jdk1.7全部按照原来方法进行计算；jdk1.8按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）

2. HashMap中put的基本流程

   当我们进行put的时候，首先会进行key值的hahs值计算，调用hash方法，hash方法实际上是让`key.hashCode()`与`key.hashCode()>>>16`进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：**高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞**。计算下标`index = (table.length - 1) & hash`

   put的主要过程：

   1. 判断键值对数组table是否为空或为null，如果为空或者null则需要resize进行扩容
   2. 根据键值key计算hash值得到插入的数组索引i
   3. 如果table[i]==null,直接新建节点添加，此时插入就算成功了，然后判断实际存在的键值对数量size是否超过最大容量threshold，如果超过就进行扩容
   4. 如果table[i]!=null,则判断首个元素是否和key一样，如果相同直接覆盖value，否则判断是否为treenode，即table[i]是否为红黑树，如果时红黑树直接插入键值对；如果不是红黑树，遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；然后判断实际存在的键值对数量size是否超过最大容量threshold，如果超过就进行扩容

3. HashMap为什么不直接使用hashcode处理后的哈希值作为table的下标

   hashcode的方法返回值时int类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，所以可以知道其实hashcode计算出来的哈希值可能不在数组大小的范围内，进而无法进行匹配。所以HashMap实现了自己的hash，

   1. 通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均
   2. 也解决了“哈希值与数组大小范围不匹配”的问题；
   3. 除此之外，在保证数组长度为2的幂的时候，使用`hash()`运算之后的值与运算（&）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率

4. HashMap为什么不线程安全

   在jdk1.8之前采用头插法，进行扩容的时候可能会造成环形链表而造成死循环；然后是可能会有数据丢失。

   在jdk1.8之后，多线程的情况下，会发生数据覆盖的情况。

5. HashMap和HashTable的区别

   大概有六点

   * 线程安全，HashMap是非线程安全，HashTable是线程安全的，HashTable内部的方法都是基本经过`synchronized` 修饰
   * 效率方面，HashMap效率高，HashTable效率低
   * **对Null key 和Null value的支持**，HashMap可是使用null为键，但是这样的键只能由一个，然后value也能够为null；HashTable中key和value都不能为null。
   * 扩容机制不同：①如果都是默认初始量，HashMap初始量为16，扩容容量变为原来两倍；HashTable初始量为11，扩容容量变为2n+1②创建时给了初始量，HashMap 会将其扩充为2的幂次方大小，而HashTable直接使用给定的大小
   * 底层数据结构不同，DK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。
   * **实现方式不同**：Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类

6. HashTable中为什么不允许键或值为 null

   因为Hashtable是**安全失败机制（fail-safe）**，这种机制会使你此次读到的数据不一定是最新的数据。如果你使用null值，就会使得其无法判断对应的key是不存在还是为空。
