1. 讲一下Volatile

   Volatile是一个关键字，主要有两个功能保证内存可见性以及禁止重排序。说起Volatile必须就得先说一下java的内存模型（JMM），JMM规定所有的共享变量都存储在主内存当中，每一个线程还有自己的工作内存，线程的工作线程 保留了被线程使用的变量的工作副本，**线程对变量的操作，都是在工作内存当中，不能直接作用于内存当中的变量**，不同线程之间也不能直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存中转化完成，因为这种工作内存和主内存的机制，导致了可见性的问题。Volatile主要就解决了这个可见性问题。

   * Volatile如何解决可见性问题？

     当我们使用Volatile修饰一个变量时，如果对这个变量进行写操作时，JMM会立即把把该线程对应的本地内存中的共享变量的值刷新到主内存；如果对这个变量进读操作，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。这个其实涉及到缓存一致性协议问题，比如Intel的MESI，当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。那么怎么发现数据是失效的？每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，所以如果大量使用Volatile，需要不断的从主存嗅探和cas不断循环，无效的交互使得总线宽达到最高峰。造成总线风暴。

   * Volatile指令从排序问题

     为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。重排序分为三种：编译器优化重排序、指令级并行重排序、内存系统的重排序，每个排序都遵守”as-if-serial“，即不管怎么重排序，单线程下的执行结果不能改变。Volatile解决内存从排序问题主要是通过**内存屏障**指令来禁止特定类型的处理器重排序，加内存屏障的方式为在Volatile写的前后分别插入StoreStore内存屏障，作用分别是禁止上面的普通写和下面的Volatile写重排序、防止上面的Volatile写和下面可能有的Volatile读/写重排序；在volatile读操作后插入一个LoadLoad内存屏障和LoadStore内存屏障，LoadLoad内存屏障的作用为禁止下面的所以普通读和上面的Volatile读重排序，LoadStore内存屏障是禁止下面所有的普通写和上面的Volatile读重排序

2. Volatile和synchronized 的区别

   * Volatile只能修饰实例变量和类变量，但是synchronized关键字可以修饰方法以及代码块
   * volatile保证数据的可见性，但是不保证原子性；synchronized是一种排他机制可以做到可见性和原子性
   * 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞
   * **volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。**