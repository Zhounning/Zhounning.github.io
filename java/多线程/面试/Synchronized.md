1. synchronized的用法

   * 修饰实例方法，其实就是给当前实例对象加锁
   * 修饰静态方法，其实就是当前类的Class对象加锁
   * 修饰代码块，给指定的一个对象加锁

2. synchronized方法和Lock的区别

   大概7点不同

   * synchronized是关键字，是jvm层面的；而Lock是一个接口是JDK层面的，具有丰富的API
   * synchronized会自动释放锁，而Lock必须手动释放锁。
   * synchronized是不可中断的，而Lock是可以中断的
   * 通过Lock可以知道是否拿到锁，而通过synchronized不能知道是否拿到锁
   * synchronized能锁住方法和代码块，而Lock只能锁住代码块。
   * Lock可以使用读锁提高多线程的效率
   * synchronized能锁住方法和代码块，而Lock只能锁住代码块。

3. 讲一讲synchronized底层原理

   * synchronized同步代码块的实现是采用monitorenter 和monitorexit 指令，。monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程会试图获取锁也就是获取 monitor的持有权，其中这个monitor是关联于对象的对象头，也就是说存在于对象的对象头中，当我们成功获取锁之后，monitor进入数就会+1。同理当执行monitorexit命令时，对应的进入数就-1，直到为0，才可以被其他线程持有。这里就体现了互斥的使用，所以能够进行同步

   * synchronized同步方法的时候，会设置一个特殊的标志位**ACC_SYNCHRONIZED**，同步方法的时候，一旦执行到这个方法，就会先判断是否有标志位，然后，ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit。

     所以归根究底，还是monitor对象的争夺。

   * monitor监视器的源码其实时C++写的，

4. 讲一讲synchronized的锁升级

   最早的时候synchronized加的锁都是重量级锁，依赖于底层的操作系统的 Mutex Lock 来实现的，所以会涉及到用户态到内核态的转换，这个状态之间的转化需要相对比较长的时间，时间成本很高。在jdk1.6之后，java官方对从jvm层面对synchronized 进行了较大的优化，引入了偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

   * 偏向锁。偏向锁的思想是大多数情况下**锁不仅不存在多线程竞争，而且总是由同一线程多次获得**。偏向锁会偏向第一个访问的线程，只要运行的过程中，该锁没有被其他线程访问，则偏向锁永远不会触发同步，连CAS都不会进行，所以效率很高。

     偏向锁实现的原理：访问锁对象的MarkWord中偏向锁标识是否设置成1，然后查看锁标志位是否为01，确认是可偏向状态。如果是可偏向状态，则测试MarkWord当中线程id是否指向当前线程，如果是，则执行同步代码。如果不是，那么通过CAS操作来竞争锁，竞争成功，则执行同步代码；竞争失败，说明有线程占有锁对象，存在竞争，当达到安全点（在这个时间点上没有字节码正在执行），会停止拥有锁的线程，然后遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态，最后唤醒停止的线程，将锁升级为轻量级锁。

     

   * 轻量级锁。偏向锁升级后就变成了轻量级锁，轻量级锁主要针对多个线程在不同时间段获得同一把锁的情况，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。

     轻量级锁加锁过程：JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，叫做Displaced Mark Word。如果一个线程获得锁的时候，发现是轻量级锁，会把锁对象的Mark Word复制到自己的Displaced Mark Word里面。复制完后，JVM会使用CAS操作尝试将对象的Mark Word替换为指向锁记录的指针，如果成功，则获得锁，如果失败，则表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。如果自选也一直不成功，则会自旋失败，该进程阻塞，同时锁升级为重量级锁。

     轻量级锁释放：

     在释放锁的时候，当前线程会使用CAS将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。

   * 重量级锁。重量级锁依赖于操作系统当中的互斥量实现，因为需要用户态切换到内核态所以效率比较低。重量级锁有多个队列，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程。Contention List：所有请求锁的线程将被首先放置到该竞争队列，Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List，Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set，OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck，Owner：获得锁的线程称为Owner，!Owner：释放锁的线程

5. 

