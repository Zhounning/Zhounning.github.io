1. 并行和并发的区别

   * 并发，多个任务在同一个cpu核上运行，是逻辑上的同时运行
   * 并行，多个任务在在多个cpu或者处理器上运行，是真正意义上的“同时运行”

2. 什么是线程死锁

   两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成彼此都阻塞的现象。

   死锁的四个必要条件：

   * 互斥
   * 占有和等待
   * 不可抢占
   * 环路等待

   死锁预防：

   * 破坏互斥条件，这个条件不可取
   * 破坏占有和等待条件，禁止已拥有资源的进程再等待其他资源。这个方法有一个实现方式，就是在进程开始执行的时候请求全部的资源，如果资源可用则分配，如果资源不可用，则不分配。这个方法理论上可行，但是不切实际，因为很多进程只有在运行的时候才知道自己需要多少资源，而且这种方式不能很好的利用资源
   * 破坏不可抢占，这个也基本不可能，比如一台打印机正在打印东西，忽然将其抢占，不切实际
   * 消除环路，实现方法一，每个进程在任何情况下都只能占有一个资源，使用第二个资源的时候必须是否第一个资源，这个方法有的时候是不可接受的。方法而给所有资源提供一个全局编号，进程在它们需要的时候请求资源，但是请求资源必须按照编号的顺序提出。这个编号方法虽然可行，但是目前找不出一种使得所有热都满意的编号方法。

3. java中创建线程的方法？

   * 继承Thread类
   * 实现Runnable接口
   * 实现Callable接口
   * 使用Executors 工具类创建线程池

4. Callable和Runnable的区别

   **`Runnable` 接口**不会返回结果或抛出检查异常，但是**`Callable` 接口**可以

5. FutureTask

6. sleep和wait有什么区别

   * 类不同，sleep()是 Thread线程类的静态方法，wait() 是 Object类的方法。
   * 是否释放锁：sleep() 不释放锁；wait() 释放锁。
   * 用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
   * 用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。

7. Thread 类中的 yield 方法有什么作用？

   使当前线程从执行状态变成可执行状态（就绪状态）

8. 并发三要素

   * 原子性
   * 可见性
   * 有序性

9. 
