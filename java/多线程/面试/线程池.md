1. 线程池的优点（三点）

   * 降低资源消耗
   * 提高响应速度
   * 提高线程的可管理性

2. 线程池的的参数

   线程池有5个必须的参数：

   * **int corePoolSize**：该线程池中**核心线程数最大值。**

   * **int maximumPoolSize**：该线程池中**线程总数最大值** 。

   * **long keepAliveTime**：**非核心线程闲置超时时长**。

   * **TimeUnit unit**：keepAliveTime的单位。

   * **BlockingQueue workQueue**：阻塞队列，维护着**等待执行的Runnable任务对象**。

     常用的几个队列有4个

     * **LinkedBlockingQueue**
     * **ArrayBlockingQueue**
     * **SynchronousQueue**
     * **DelayQueue**

   还有3个非必须参数

   * **ThreadFactory threadFactory**：创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。

   * RejectedExecutionHandler handler

     **拒绝处理策略**，如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，就会采用拒绝处理策略，四种拒绝处理的策略为 ：

     * **`ThreadPoolExecutor.AbortPolicy`**：**默认拒绝处理策略**，丢弃任务并抛出RejectedExecutionException异常。
     * **`ThreadPoolExecutor.DiscardPolicy`：** 丢弃新来的任务，但是不抛出异常。
     * **`ThreadPoolExecutor.DiscardOldestPolicy`：** 丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。
     * **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。

3. 线程池的状态

   在线程池种定义了一个`volatile int`变量**runState**来表示线程池的状态 ，一共有**5**个状态分别为RUNNING、SHUTDOWN、STOP、TIDYING 、TERMINATED。

   * 线程池创建后的状态RUNNING
   * 线程池调用shutdown()方法后处于**SHUTDOWN**状态。**SHUTDOWN**状态下线程池不能接受新的任务，清除一些空闲的worker，等阻塞队列任务完成。
   * 调用shutdownNow()方法后处于**STOP**状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0。
   * 当所有任务完成后，线程池变成**TIDYING**状态。接着会执行terminated()函数。
   * 执行terminated()函数后，线程池变成**TERMINATED**状态。

4. 线程池的过程

   1. 当线程总数量<corePoolsize,无论线程是否空闲，都会新建一个核心线程执行任务。
   2. 当线程数量>=corePoolsize时，新来的线程任务会进入到任务队列当中进行等待，然后空闲的核心线程会依次去缓存队列中去任务来执行(体现了线程复用)
   3. 当缓存队列满了，说明这个时候任务已经非常多了，着时候需要更多的线程去完成任务，所有会创建非核心线程去执行这个任务
   4. 当缓存满了，并且总线程数量达到maximumPoolSize，则会采用拒绝策略去进行处理

5. 几种常见的线程池