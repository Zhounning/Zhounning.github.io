1. 进程和线程的区别

   1. **进程是资源分配的最小单位，线程是CPU调度的最小单位**

   2. 线程在进程下行进，一个进程可以包含多个线程

   3. 进程和进程下的不同数据很难共享，同一进程下不同线程数据很易共享

   4. 进程要比线程消耗更多的计算机资源

   5. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉

2. 从操作系统的层次来看，进程有哪些状态，进程状态之间的转化

   1. 进程有5个状态，创建、终止、就绪、运行、阻塞状态
      * 创建：系统完成创建进程的一系列工作后进程的状态（进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配）
      * 终止：进程结束，或出现错误，或被系统终止，进入终止状态
      * 就绪：进程已经准备好，分配到了所需要的资源，等待分配cpu就能运行
      * 运行：在cpu上运行
      * 阻塞：正在执行的进程因为某些事件（如：io请求等）而暂时无法运行
   2. 状态之间转化
      * 就绪态到运行态：进程调度
      * 运行态到阻塞态：进程申请某种系统资源，或者请求等待某个事情发生
      * 阻塞态到就绪态：申请的资源被分配，或者等待的事件发生

3. 讲讲系统调用？讲一讲用户态和内核态

   * 计算机系统中各种硬件资源是有限的，比如内存2G，cpu4核。为了更好的管理这些资源，进程不允许直接操作的，所有对这些资源的访问都必须由操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的**系统调用（System Call）**，可以把系统调用理解为一些接口，用来调用资源（高级语言中的库函数，其实就是调用了这些接口）。

   * 在linux当中，操作系统将权限分为了2个等级，分别为内核态和用户态，用户态的进程能够访问的资源受到很大限制，内核态相对来说就为所欲为一些，基本上可以访问计算机系统中任何资源。

   * 用户态切换到内核态的三种方式：
     * 系统调用
     * 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换
     * 外围设备中断
     
   * 系统调用为什么开销很大？
     
     * 待定。。。。
     
   * 系统调用按照功能功能大致可以分为几类
     
     大概5类
     
     * 设备管理
     * 文件管理
     * 进程控制
     * 进程通信
     * 内存管理

4. 进程间的通讯方式？

   1. 匿名管道（pipe）：进程间通讯的一种方式，我们调用pipe函数，会在内核中开辟出一块缓冲区用来进行进程间通信，这块缓冲区称为管道，它有一个读端和一个写端。pipe函数接受一个参数，是包含两个整数的数组，如果调用成功，会通过pipefd[2]传出给用户程序两个文件描述符，需要注意pipefd [0]指向管道的读端, pipefd [1]指向管道的写端，那么此时这个管道对于用户程序就是一个文件，可以通过read(pipefd [0]);或者write(pipefd [1])进行操作。pipe函数调用成功返回0，否则返回-1。
      * pipe只能单向通信
      * 只能有血缘关系的进程进行通信
      * 依赖于文件系统
      * 面向字节流服务
      
   2. 命名管道：命名管道是一个设备文件，也被称作FIFO文件，特点是第一个被写入的数据将首先从管道中读出。

      * 创建命名管道的函数为mknod和mkfifo，这两个函数都能够创建一个FIFO文件，这个文件真实存在于文件系统（磁盘）。

        ```c
        int mkfifo(const char *filename, mode_t mode);
        int mknod(const char *filename, mode_t mode | S_IFIFO, (dev_t)0);
        //filename指定了文件名，而mode则指定了文件的读写权限。
        //mknod是比较老的函数，而使用mkfifo函数更加简单和规范，所以建议在可能的情况下，尽量使用mkfifo而不是mknod。
        ```

      * 在创建FIFO文件之后， 可以使用open函数打开

      * 可能会存在多个进程想一个文件写数据，而只有一个读进程读取数据时，发生数块相互交错的问题。解决方法是使得写操作原子化，在一个以O_WRONLY（即阻塞方式）打开的FIFO中， 如果写入的数据长度小于等待PIPE_BUF，那么或者写入全部字节，或者一个字节都不写入。如果所有的写请求都是发往一个阻塞的FIFO的，并且每个写记请求的数据长度小于等于PIPE_BUF字节，系统就可以确保数据决不会交错在一起。

   3. 共享内存：共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，进程可以将同一段共享内存连接到他们自己的地址空间中，所有进程都可以访问共享内存中的地址，而且如果某个经常向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进。

      **需要注意的** ：共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。shmget函数用于创建共享内存，shmat函数用于启动对该共享内存的访问。

      1、优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。

      2、缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。

   4. 信号：信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应的采取一些行动。一般来说，信号是由一个错误产生的，但是他们还可以作为进程间通信或者修改行为的一种方式，明确由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。

   5. 信号量：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件，简单来说就是P操作和V操作

      * semget函数，创建一个信号量
      * semop函数，作用是改变信号量的值

   6. 消息队列：消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法，类似于管道的通信方式效率很低，不适合进程间频繁地交换数据，消息队列刚好解决这个问题。

      * msgget函数，该函数用来创建和访问一个消息队列
      * msgsnd函数，该函数把消息添加到消息队列中
      * msgrcv函数，该函数用来从一个消息队列获取消息
      * 缺点：通信不及时，发送内容有大小限制，不适合大数据的传输（因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。）

   7. 套接字

5. 进程的调度算法，各自的优缺点

   大概5种
   
   * 先来先服务
     * 按照作业/进程到达的先后顺序进行服务。
     * 非抢占式的算法
     * 优点：公平，算法实现简单，缺点：排在长作业后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即FCFS对长作业有利，对短作业不利。
     * 不会导致饥饿
   * 短作业优先
     * 最短的作业、进程优先得到服务（所谓“最短”，是指要求服务时间最短）
     * 可以抢占可以非抢占
     * 优点：“最短的”平均等待时间，平均周转时间。缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。
     * 可能导致饥饿
   * 时间片轮转
     * 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
     * 可抢占式。
     * 优点：公平，响应快，适用于分时操作系统。缺点：用于高频率的进程切换，有一定的开销，不区分任务的紧急程度
     * 不会导致饥饿
   * 优先级调度
     * 每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
     * 抢占/非抢占都有。
     * 优点：用优先级区分紧急程度，重要程度，适用于实时操作系统。可灵活的调整对各种作业/进程的偏好程度。缺点：若源源不断地有高优先级进程到来，则可能导致饥饿
     * 会导致饥饿
   * 多级反馈队列
     * 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大，新进程到达时先进入第一队列，只有第k即队列为空时，才会为第 k+1 级对头的进程分配时间片
     * 抢占式算法
     * 相对公平，每个新到达的进程都可以很快得到响应，可灵活地调整对各类进程的偏好程度，比如CPU密集型进程，I/O密集型
   
   