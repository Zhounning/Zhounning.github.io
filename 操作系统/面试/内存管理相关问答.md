1. 内存管理主要是干什么？

   * 基本的内存管理，类似于内存的分配、回收等
   * 存储保护，防止一个进程被其他进程破坏
   * 地址映射，将逻辑地址转换成虚拟地址，最终转化成物理地址
   
2. 虚拟地址和物理地址讲解一下？

   * 在以前的时候，计算机的内存比较小，一般是以k为单位进行计算，但是当时的程序规模并不大，所以采用的方法为将程序全部加载进内存，然后随着计算机的发展程序变大了，内存无法全部加载进内存，程序员们就采用了一种叫做交换的方法，先将程序分割成许多个覆盖块，先运行覆盖块0，然后再运行覆盖块1的这种方法，但是这种方法比较麻烦，需要程序员对程序进行分割，为了比较好的解决这个问题，人们利用局部性原理，接着发展出了虚拟存储器的思想，虚拟存储器的基本思想是程序，数据，堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存中。所以出现了
   * 逻辑地址又叫相对地址是编程时可以接触到的，逻辑地址由段标识符和段内偏移量组成，表示相对于段的偏移，通常表示一个指令的地址或者数据的地址，我们程序员平时打交道的就是逻辑地址。
   * 虚拟地址又叫线性地址，是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址
   * 物理地址，内存当中实际的地址
   * 通常cpu将一个逻辑地址转化为物理地址，需要两步：首先给定一个逻辑地址，CPU要**利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址，再利用其页式内存管理单元，转换为最终物理地址**。
   
3. 常见的几种内存管理机制

   * 块式管理：远古时期计算机系统的内存管理方式，将内存分为几个固定大小块，每个块中包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
   * 段式管理：段式管理把主存分为一段段的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等，每一段都有自己具体的含义。 段式管理通过段表对应逻辑地址和物理地址，分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**。段选择因子保存在寄存器当中，由段号和特权标志位组成，段号用作段表的索引，查找段号就可以对应的查找出**段的基地址、段的界限和特权等级**等，**段的基地址**加上开始段偏移量九九可以得到物理内存地址。
     * 段式管理的优点是解决了程序本身不需要关心具体的物理内存地址的问题，缺点是产生了很多外碎片，然后程序所有的内存都被装载到了物理内存当中，有部分内存可能并不是很常用，这也会导致内存的浪费。
     * 为了解决外碎片的问题，会采用内存交换的方法，先将内存中的程序写到磁盘上，再进行加载，这样能留出更多内存空间，但是由于硬盘的访问速度比内存慢太多，每一次内存交换我们都需要把一大段内存数据写到硬盘上。所以，**如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。**
   * 页式管理：把内存分为大小相等且固定的一页一页的形成，页的颗粒较小，相对相比于块式管理的划分力度更大，提高了内存利用率。页式管理中虚拟地址与物理地址之间通过页表进行映射。相比于分段，内存空间都是预先划分好的，不会像分段那样产生内存碎片，如果内存空间不够，操作系统会通过页面置换算法将不需要的页写到磁盘上，然后将需要的页加载进来，相比于段式管理里面的交换一个程序，内存交换的效率会高很多。更进一步，分页的方式使得我们在加载程序的时候，不需要一次性把程序加载到物理内存中，我们只需要在程序运行的时候，**只需要用到对应虚拟内存页里面的指令和数据时，加载到物理内存里面去。**更好的利用了局部性原理
     * 页表会占用一定空间，而且每个进程都占有一个页表，所以为了节约空间采取多级页表的方法。在32位环境下，虚拟地址空间有4GB，假设一页的大小4KB(2^12),那么就需要(2^20)100万个页，每个页表项需要4个字节大小，那么需要4MB来存页表，然后每个进程都有自己的页表，100个进程就要`400MB` 的内存来存储页表，这是比较大的内存消耗。为了解决这个问题，我们使用多级页表，将2^20个页表再分页，将页表（一级页表）分为 `1024` 个页表（二级页表），每个表（二级页表）中包含 `1024` 个「页表项」，形成**二级分页**。当然这样分了之后乍一看就需要4KB（一级页表）+ 4MB（二级页表）的内存，但是这是给每个进程4GB的虚拟地址空间，但是很多时候使用到的空间远未达到 4GB，因此对应部分的页表项为空。如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但**如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表**。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= `0.804MB`，这对比单级页表的 `4MB` 是一个巨大的节约。
     * 为了加快访问的速度，我们还使用了TLB进行页表缓存加快了访问速度
   * 段页式管理：将段式管理和页式管理相结合的管理，段页式内存管理实现的方式：先将程序划分为多个有逻辑意义的段，然后再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；这样，地址结构就由**段号、段内页号和页内位移**三部分组成。用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号。这样段页式地址变换中要得到物理地址须经过三次内存访问：
     * 第一次访问段表，得到页表起始地址；
     * 第二次访问页表，得到物理页号；
     * 第三次将物理页号与页内位移组合，得到物理地址。
   
4. 页面置换算法
   

大概7种

* OPT最优页面置换算法，当一个缺页中断发生时，对于内存中的每一个虚拟页面，计算在它的下一次访问之前，还需要等待多长的时间，将等待时间最长的那个页面置换出来。最优置换算法的缺点是无法实现，操作系统不知道下一个页面需要等待多长时间
  
* FIFO先进先出页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。先进先出页面置换算法的优点是比较容易实现，操作系统维护一个链表即可，缺点是可能会淘汰出经常访问的页面
  
   * NRU最近未使用算法，在页表项当中通常有修改位M和访问位R，当一个页面被访问时（包括读操作也写操作），它的R位会被设置位1，而当这个页面被修改时(即该页面被写入数据)，它的M位会被设置为1。在进程开始的时候，R位和M位都会被设置位0，然后再运行的过程中R位会被定期清零（每次时钟中断），这样就能把最近未被访问过的页面与最近被访问过的页面区分开来（这个最近，指的是上个时钟中断到当前的时钟中断）。通过R位和M位我们将页面分为4类
   
     * 第0类：未被访问，未被修改（R=0,M=0）
  * 第1类：未被访问，已被修改(R=0,M=1)
     * 第2类：已访问,未修改(R=1,M=0)
  * 第3类：已访问，已修改（R=1,M=1）
  
  然后我们的做法是随机地从编号最小的非空类中挑选一个页面，把它淘汰出去。NRU思想简单，便于理解和 实现，但是使用起来效率不高
  
* 第二次机会页面置换算法
  
  第二次机会页面置换算法是在FIFO的基础上的改进，对于将要置换出去的那个页面，我们去检查它的R位，如果R位是0，说明这个页面老且无用，就立即将其淘汰出去，如果R位为1，则说明该页面曾经被访问过，就再给它一次机会，将R位清0，放置到链表的尾端，这个算法缺点是在链表中需要移动页面。
  
* LRU最近最近未使用算法
  
  LRU的基本思想是当发生缺页中断时，选择最长时间没有被访问的页面进行置换，这个算法假设已经很久没有使用的页面很有可能再未来较长时间内任然不会被使用。LRU的实现方式是再内存当中维护一个页面链表，将最近使用的页面放在表头，最近使用少的页面放在表尾，发生缺页中断的时候只需要淘汰表尾的页面即可。但是这个算法缺点是每次访问内存时，都必须更新整个链表，在链表中找到一个页面，删除它，然后把它移动到表头，这是一个比较费时的操作，所以LRU看上去不错，实际上开销很大。
  
* 时钟页面置换算法
  
     时钟页面置换算法的思想是，把所以的页面都保存再一个类似钟面的环形链表中，一个表针指向最老的页面（在内存中待的时间最长的页面），当发生缺页中断时，算法首先检查表针指向的页面，如果它的访问位R为0就淘汰该页面，并把新的页面插入到这个位置，然后把表指针前移一个位置，如果访问为是1就立刻清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。这个算法的有点是不需要移动页面，开销少，效率高
   
   * LFU最不常用算法。算法的思想是对面个页面设置一个访问计数器，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。这个算法看起来很简单，但是缺点很大，要给每个页面增加一个计数器，硬件成本增加，然后计数器中还需要查找访问次数最小的那个页面，如果链表长度很大，是非常耗时的，效率不高。而且LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。
   
5. 磁盘调度算法

   4种

   * 先来先服务，先来的磁道先访问，优点变焦简单，缺点当大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法性能可能很差，因此寻道时间很长
   
   * 最短寻道时间优先，优先选择当前磁头位置所需寻道时间最短的请求，优点比先来先服务磁头移动总距离少，性能提升不少，但是这个算法可能导致某些请求饥饿。
   * 电梯算法，也叫扫描算法磁头在一个方向上移动，访问所有未完成请求，知道磁头到达该方向上最后的磁道再调换方向。电梯算法性能好不会产生饥饿，到那时存在中间的磁道比较占便宜的现象
   * 循环扫描算法，思想为只有磁头朝某个方向移动时，才出来磁道访问请求，而且返回直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且**返回中途不处理任何请求**，该算法的特点，就是**磁道只响应一个方向上的请求**。
   
     
   
     





