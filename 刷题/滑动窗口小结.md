# 滑动窗口小结

刷LeetCode的时候遇到了两题困难的滑动窗口问题，滑动窗口是典型的双指针问题，思想简单但是编写起来还是有点复杂

## 串联所有单词的子串

### 题目描述

给定一个字符串 **s** 和一些长度相同的单词 **words**。找出 **s** 中恰好可以由 **words** 中所有单词串联形成的子串的起始位置。

注意子串要与 **words** 中的单词完全匹配，中间不能有其他字符，但不需要考虑 **words** 中单词串联的顺序。

 

**示例 1：**

```
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```

**示例 2：**

```
输入：
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
输出：[]
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

采用滑动窗口的方法，窗口的长度就是words总单词的长度

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> res = new ArrayList<>();
        if (s == null || s.length() == 0 || words == null || words.length == 0) return res;
        HashMap<String, Integer> map = new HashMap<>();
        int word_length = words[0].length();
        int word_num = words.length;
        for (String word : words) {
            map.put(word, map.getOrDefault(word, 0) + 1);
        }
        //滑动窗口，分情况
        //将所有移动分成 word_length 类情况，对于单词长度进行遍历
        for (int i = 0; i < word_length; i++) {
            int left = i, right = i, count = 0;
            HashMap<String, Integer> tmp_map = new HashMap<>();
            //每次移动一个单词长度
            while (right + word_length <= s.length()) {
                //得到子串
                String w = s.substring(right, right + word_length);
                right += word_length;
                //判断子串
                if (!map.containsKey(w)) {
                    //不能有其他字符
                    count = 0;
                    //窗口进行滑动
                    left = right;
                    tmp_map.clear();
                } else {
                    tmp_map.put(w, tmp_map.getOrDefault(w, 0) + 1);
                    count++;
                    //发现次数多了
                  //窗口进行滑动，一直移除单词，直到次数符合了
                    while (tmp_map.getOrDefault(w, 0) > map.getOrDefault(w, 0)) {
                        String t_w = s.substring(left, left + word_length);
                        count--;
                        tmp_map.put(t_w, tmp_map.getOrDefault(t_w, 0) - 1);
                        left += word_length;
                    }
                    if (count == word_num) res.add(left);
                }
            }
        }
        return res;
    }
}
```

主要参考https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/

这题思路有了之后，就比较简单，但是在编程上还是有一些细节



## 最小覆盖子串

### 题目描述

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

**示例：**

```
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```

**说明：**

* 如果 S 中不存这样的子串，则返回空字符串 ""。
* 如果 S 中存在这样的子串，我们保证它是唯一的答案。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-window-substring
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

这个跟上面类似，也是一个字符串里面找子串，所有同样可以用滑动窗口完成，同样需要记录T中各个字符出现的次数

官方题解如下

```java
class Solution {
    //记录原字符中出现的次数
    Map<Character, Integer> ori = new HashMap<Character, Integer>();
    //记录窗口中单词出现的次数
    Map<Character, Integer> cnt = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        //初始化
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            ori.put(c, ori.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        int sLen = s.length();
        
        while (r < sLen) {
            ++r;
            //如果包含则加入，r右滑动
            if (r < sLen && ori.containsKey(s.charAt(r))) {
                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
            }
            //检查成功
            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                //l右滑，缩小窗口
                if (ori.containsKey(s.charAt(l))) {
                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }
	//检查l到r是否包含子串
    public boolean check() {
        Iterator iter = ori.entrySet().iterator(); 
        while (iter.hasNext()) { 
            Map.Entry entry = (Map.Entry) iter.next(); 
            Character key = (Character) entry.getKey(); 
            Integer val = (Integer) entry.getValue(); 
            if (cnt.getOrDefault(key, 0) < val) {
                return false;
            }
        } 
        return true;
    }
}

```

然后在评论区看到一个更妙的，使用`int[] mp = new int[256]`记录字符出现的次数，也比较巧妙，并且速度更快，再字符多的时候说不定更节约内存，方法巧妙，可以借鉴

```java
class Solution {
    public String minWindow(String s, String t) {
        //mp相当于哈希表
        int[] mp = new int[256];
        //记录t中字符出现的次数
        for (char c : t.toCharArray()) mp[c] += 1;
        int start = 0, end = 0;
        int n = s.length(), m = t.length();
        int cnt = 0;
        int minlen = -1;
        String ans = "";
        while (end < n) {
            char c = s.charAt(end);
            mp[c] -= 1;
            //所有的t都被包含时
            if (mp[c] >= 0) cnt += 1;
            while (cnt == m) {
                if (minlen == -1 || minlen > end - start + 1) {
                    ans = s.substring(start, end + 1);
                    minlen = end - start + 1;
                }
                c = s.charAt(start);
                //次数恢复
                mp[c] += 1;
                if (mp[c] >= 1) cnt -= 1;
                //start右滑
                start += 1;
            }
            //end右滑
            end += 1;
        }
        return ans;
    }
}
```

## 总结

就这两题滑动窗口来说，都是类似于在一个字符串中寻找子串的问题，总结起来就是需要使用哈希表记录对于字符或者字符串的次数，然后使用双指针维护窗口

