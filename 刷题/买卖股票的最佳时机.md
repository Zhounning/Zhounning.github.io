# 买卖股票的最佳时机

## 121.买卖股票的最佳时机

### 题目描述

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

这里只能进行一次交易，那我们选择相对来说差距最大的两个才行，有一种动态规划的思想在里面

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null)
            return 0;
        int minPrice = Integer.MAX_VALUE;
        int maxNum = 0;

        for (int i = 0; i < prices.length; i++) {
            
            minPrice = Math.min(minPrice, prices[i]);
            maxNum = Math.max(maxNum, prices[i]-minPrice);
        }
        return maxNum;
    }
}
```

## 122.买卖股票的最佳时机II

### 题目描述

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```


提示：

* 1 <= prices.length <= 3 * 10 ^ 4
* 0 <= prices[i] <= 10 ^ 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

可以进行多次股票买卖

思想一：贪心，贪心算法的决策是：**只加正数**。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for(int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i -1]) {
                profit  = profit + prices[i] - prices[i - 1];
            }
        }    
        return profit;    
    }
}
```

思想二：峰谷法

假设给定的数组为：

[7, 1, 5, 3, 6, 4]

如果我们在图表上绘制给定数组中的数字，我们将会得到：

![](https://gitee.com/zhou-ning/BlogImage/raw/master/刷题/d447f96d20d1cfded20a5d08993b3658ed08e295ecc9aea300ad5e3f4466e0fe-file_1555699515174.png)

如果我们分析图表，那么我们的兴趣点是连续的峰和谷。

其实最大值就算波峰剪对应的波谷的累加，其实用单调栈也是同样可以做出来，思想类似

```java
class Solution {
    public int maxProfit(int[] prices) {
        int i = 0;
        int valley = prices[0];
        int peak = prices[0];
        int maxprofit = 0;
        while (i < prices.length - 1) {
            while (i < prices.length - 1 && prices[i] >= prices[i + 1])
                i++;
            valley = prices[i];
            while (i < prices.length - 1 && prices[i] <= prices[i + 1])
                i++;
            peak = prices[i];
            maxprofit += peak - valley;
        }
        return maxprofit;
    }
}
```

思想三：动态规划，能用贪心的一定能够使用动态规划，只是这题的动态规划不好想，直接转载https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/

想到动态规划的原因是：可以用贪心算法解决的问题，一般情况下都可以用动态规划。因此，不妨从 “状态”、“状态转移方程” 的角度考虑一下，使用动态规划的思路解决这道问题。

根据 「力扣」第 121 题的思路，需要设置一个二维矩阵表示状态。

**第 1 步：定义状态**
状态 dp\[i][j] 定义如下

第一维 i 表示索引为 i 的那一天（具有前缀性质，即考虑了之前天数的收益）能获得的最大利润；
第二维 j 表示索引为 i 的那一天是持有股票，还是持有现金。这里 0 表示持有现金（cash），1 表示持有股票（stock）。
**第 2 步：思考状态转移方程**
状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash）；
每一天状态可以转移，也可以不动。状态转移用下图表示：

![](https://gitee.com/zhou-ning/BlogImage/raw/master/刷题/041a4d01398359409ecc69dacc13a44d179dd1a2a9f43b1def80e9a6acceee55-image.png)


（状态转移方程写在代码中）

说明：

因为不限制交易次数，除了最后一天，每一天的状态可能不变化，也可能转移；
写代码的时候，可以不用对最后一天单独处理，输出最后一天，状态为 0 的时候的值即可。
**第 3 步：确定起始**
起始的时候：

如果什么都不做，dp\[0][0] = 0；
如果买入股票，当前收益是负数，即 dp\[0][1] = -prices[i]；
**第 4 步：确定终止**
终止的时候，上面也分析了，输出 dp\[len - 1][0]，因为一定有 dp\[len - 1][0] > dp\[len - 1][1]。

```java
public class Solution {

    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2) {
            return 0;
        }

        // 0：持有现金
        // 1：持有股票
        // 状态转移：0 → 1 → 0 → 1 → 0 → 1 → 0
        int[][] dp = new int[len][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[len - 1][0];
    }
}
```

感觉十分难想象到，然后可以进行优化

```java
public class Solution {

    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2) {
            return 0;
        }

        // cash：持有现金
        // hold：持有股票
        // 状态转移：cash → hold → cash → hold → cash → hold → cash

        int cash = 0;
        int hold = -prices[0];

        int preCash = cash;
        int preHold = hold;
        for (int i = 1; i < len; i++) {
            cash = Math.max(preCash, preHold + prices[i]);
            hold = Math.max(preHold, preCash - prices[i]);

            preCash = cash;
            preHold = hold;
        }
        return cash;
    }
}
```

## 123.买卖股票的最佳时机 III

### 题目描述

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

这次限制了交易的次数为2，这样看来前三题其实只是次数上的不同，有了上题的基础后就比较好理解了。

```java
class Solution {
    public int maxProfit(int[] prices) {
    	int T_i10 = 0, T_i11 = Integer.MIN_VALUE;
    	int T_i20 = 0, T_i21 = Integer.MIN_VALUE;

        for (int price : prices) {
            T_i20 = Math.max(T_i20, T_i21 + price);
            T_i21 = Math.max(T_i21, T_i10 - price);
            T_i10 = Math.max(T_i10, T_i11 + price);
            T_i11 = Math.max(T_i11, -price);
        }
        
    	return T_i20;
    }
}
```

## 188.买卖股票的最佳时机IV

### 题目描述

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [2,4,1], k = 2
输出: 2
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```


**示例 2:**

```
输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

思路看下面思路总结

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
    if (k >= prices.length >>> 1) {
        //相当于k为无限的情况
        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
        for (int price : prices) {
            int T_ik0_old = T_ik0;
            T_ik0 = Math.max(T_ik0, T_ik1 + price);
            T_ik1 = Math.max(T_ik1, T_ik0_old - price);
        }
        
        return T_ik0;
    }
        
    int[] T_ik0 = new int[k + 1];
    int[] T_ik1 = new int[k + 1];
    Arrays.fill(T_ik1, Integer.MIN_VALUE);
        
    for (int price : prices) {
        for (int j = k; j > 0; j--) {
            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);
            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);
        }
    }
        
    return T_ik0[k];
    }
}
```

## 309.最佳买卖股票时机含冷冻期

### 题目描述

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
* 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

```java
class Solution {
    public int maxProfit(int[] prices) {
    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);
        T_ik0_pre = T_ik0_old;
    }
    
    return T_ik0;
    }
}
```

## 714.买卖股票的最佳时机含手续费

### 题目描述

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意**：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1:**

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

**注意**:

* `0 < prices.length <= 50000.`
* `0 < prices[i] < 50000.`
* `0 <= fee < 50000.`



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 代码

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
            int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);
    }
        
    return T_ik0;
    }
}
```



## 思路总结 

做了k=1，k=2和k=无穷多后，我参考别人的博客，发现其实这题有一个同一的解法。翻译题解：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems

### 一、分析

首先，让我们阐明表示法以简化我们的分析。令价格为长度为`n`的股票价格数组`prices`，`i`表示第`i`天（`i`从`0`到`n-1`），`k`表示允许完成的最大交易数，`T[i][k]`为在第`i`天结束时最多可进行k笔交易可获得的最大利润。显然，我们有基本情况：`T[-1][k]= T[i][0] = 0`，即没有股票或没有交易产生任何利润（请注意，第一天的i = 0，所以i = -1表示没有库存）。现在，如果我们能够以某种方式将`T[i][k]`与其子问题相关联，例如`T [i-1] [k]，T [i] [k-1]，T [i-1] [k-1]，...。 ..`，我们将有一个有效的递归关系，并且可以递归解决该问题。那么我们如何实现呢？

最直接的方法是查看第`i`天采取的措施。我们有几种选择？答案是三个：买，卖，休息。我们应该选哪一个？答案是：我们并不真正知道，但是找出哪一个很容易。如果没有其他限制，我们可以尝试每一种选择，然后选择使我们的利润最大化的选择。但是，我们确实有一个额外的限制，即不允许同时进行多次交易，这意味着如果我们决定在第i天进行购买，那么在购买之前，我们手中应该持有0只股票；如果我们决定在第i天卖出，则在我们卖出之前，我们手中应该只持有1只股票。我们手中持有的股票数量是上述隐藏的因素，它将影响第i天的操作，从而影响最大利润。

因此，我们对`T[i][k]`的定义实际上应该分为两部分：`T[i][k][0]`和`T[i][k][1]`，其中前者表示在第i天交易股票获得的利润最大，k笔交易后手头有0只股票，而后者表示第`i`天结束时的最大利润，最多交易数`k`笔交易中有1只股票采取行动后，伸出一只手。现在，基本案例和递归关系可以写成：

1. 基本情况

   `T[-1][k][0] = 0, T[-1][k][1] = -Infinity`
   `T[i][0][0] = 0, T[i][0][1] = -Infinity`

2. 递归关系：

   `T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`
   `T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])`
   
   这个关系在前面有例子之后更好理解

对于基本情况，`T [-1] [k] [0] = T [i] [0] [0] = 0`具有与以前相同的含义，而`T[-1] [k] [1] = T[i] [0][1] = -Infinity`强调一个事实，即如果没有可用的库存或不允许进行交易，那么我们手头就不可能有1只库存。

对于循环关系中的`T [i] [k] [0]`，在第i天采取的行动只能是休息和出售，因为在一天结束时我们手中的股票为0。如果采取行动休息，`T [i-1] [k] [0]`是最大利润，而采取行动卖出的则`T[i-1][k][1] + prices[i]`。请注意，由于交易包含两个成对出现的交易（即买入和卖出），因此允许交易的最大数量保持不变。只有行动购买会改变允许的最大交易数量。

对于递归关系中的`T [i] [k] [1]`，在第`i`天采取的行动只能休息或者购买，因为在一天结束时我们手中只有1只股票。如果采取行动休息，`T[i-1][k][1]`是最大利润，如果采取行动买入， `T[i-1][k-1][0] - prices[i]` 是最大利润。采取。请注意，允许交易的最大数量减少了一个，因为在第i天进行购买将使用一次交易，如上所述。

要找到最后一天结束时的最大利润，我们可以简单地遍历价格数组并根据上述重复关系更新`T [i] [k] [0]`和`T [i] [k] [1] `。最终答案将是`T [i] [k] [0]`（如果最终手头有0只股票，我们总是有更大的利润）。

另外需要一提的是虽然上面是三维表达式，但是可以通过滚动数组等方式进行降维

### 二、实际例子

#### 案例一：k=1,也就是第一题

对于这种情况，我们实际上每天都有两个未知变量：`T[i][1][0]`和`T[i][1][1]`，递归关系说：

```
T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])
T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])
```

在这里，我们针对第二个方程利用了基本情况`T [i] [0] [0]` = 0。所以最终变成

```java
public int maxProfit(int[] prices) {
    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;
        
    for (int price : prices) {
        T_i10 = Math.max(T_i10, T_i11 + price);
        T_i11 = Math.max(T_i11, -price);
    }
        
    return T_i10;
}
```

现在，让我们尝试对上述解决方案有所了解。如果我们更仔细地检查循环中的部分，则`T_i11`实际上只是表示第`i`天之前所有股价的负值的最大值，或者等效地表示所有股价的最小值。至于`T_i10`，我们只需要决定哪个动作产生更高的利润，即卖出还是休息。如果采取卖空行动，我们买入股票的价格为`T_i11`，即第i天之前的最小值。如果我们想获得最大的利润，这正是我们在现实中会做的事情。我应该指出，这不是解决这种情况的唯一方法。您可能会在这里找到其他不错的解决方案。

#### 案例二：k=+Infinity,也就是第二题

如果k为正无穷大，则`k`与`k-`1之间实际上没有任何区别，这意味着`T[i-1][k-1][0]` = `T [i -1] [k] [0]`和`T [i-1] [k-1] [1] = T [i-1] [k] [1]`。因此，我们每天仍有两个未知变量：`T [i] [k] [0]和T [i] [k] [1]`，其中`k = + Infinity`，递归关系说：

```
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])
```

这里我们利用了第二个方程`T [i-1] [k-1] [0] = T [i-1] [k] [0]`的事实。 `O(n)`时间和`O(1)`空间解如下：

```java
public int maxProfit(int[] prices) {
    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price);
    }
    
    return T_ik0;
```

（注意：不需要缓存T_ik0的旧值，即变量T_ik0_old。特别感谢0x0101和elvina对此进行了说明。） 该解决方案提出了一种获取最大利润的贪婪策略：尽可能长的时间，在每个局部最小值处购买股票，并在紧随其后的局部最大值处出售。这等同于找到价格上涨的子阵列（股票价格阵列），并以每个子阵列的起始价格购买，同时以其最终价格出售。很容易证明这与累积利润相同，只要这样做是有利可图的，正如本文所展示的。

#### 案例三：k=2,也就是第三题

类似于`k = 1`的情况，除了现在我们有四个变量而不是每天有两个变量：`T [i] [1] [0]，T [i] [1] [1]，T [i] [2 ] [0]，T [i] [2] [1]`和递归关系为：

```
T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])
T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])
T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])
T[i][1][1] = max(T[i-1][1][1], -prices[i])
```

在这里，我们再次利用了基本情况`T [i] [0] [0] = 0`的最后一个方程式。` O（n）`时间和`O（1）`空间解如下：

```java
public int maxProfit(int[] prices) {
    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;
    int T_i20 = 0, T_i21 = Integer.MIN_VALUE;
        
    for (int price : prices) {
        T_i20 = Math.max(T_i20, T_i21 + price);
        T_i21 = Math.max(T_i21, T_i10 - price);
        T_i10 = Math.max(T_i10, T_i11 + price);
        T_i11 = Math.max(T_i11, -price);
    }
        
    return T_i20;
}
```

这与此处给出的基本相同。

#### 案例四：k是任意的

这是最普遍的情况，因此每天我们都需要在一天结束时用不同的`k`值（对应于0或1只股票）更新所有最大利润。但是，如果`k`超过某个临界值，我们可以做一个较小的优化，超过这个临界值，最大利润将不再取决于允许的交易数量，而是由可用股票的数量（价格数组的长度）限制。让我们弄清楚这个临界值是什么。 有利可图的交易至少需要两天的时间（一天买入，另一天卖出，前提是买入价低于卖出价）。如果价格数组的长度为`n`，则获利交易的最大数量为`n / 2`（整数除法）。之后，将无法进行任何有利可图的交易，这意味着最大利润将保持不变。因此，`k`的临界值为`n / 2`。如果给定的k不小于该值，即`k> = n / 2`，我们可以将k扩展到正无穷大，并且问题等同于情况II。 以下是`O（kn）`时间和`O（k）`空间解。如果不进行优化，则TLE会满足较大`k`值的代码。

```java
public int maxProfit(int k, int[] prices) {
    if (k >= prices.length >>> 1) {
        //相当于k为无限的情况
        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
        for (int price : prices) {
            int T_ik0_old = T_ik0;
            T_ik0 = Math.max(T_ik0, T_ik1 + price);
            T_ik1 = Math.max(T_ik1, T_ik0_old - price);
        }
        
        return T_ik0;
    }
    //也可以由一个三维数组表示
    int[] T_ik0 = new int[k + 1];
    int[] T_ik1 = new int[k + 1];
    Arrays.fill(T_ik1, Integer.MIN_VALUE);
        
    for (int price : prices) {
        for (int j = k; j > 0; j--) {
            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);
            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);
        }
    }
        
    return T_ik0[k];
}
```

#### 案例五：k=+Infinity但是有冷冻期

案例与案例II非常相似，因为它们具有相同的k值，不同之处在于现在必须对递归关系进行一些修改以解决“冷却”要求。案例二的原始递归关系由下式给出

```
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])
```

但是，由于“冷却”，如果在第（i-1）天卖出股票，我们将无法在第i天购买股票。因此，在上述第二个公式中，如果要在第i天购买，我们实际上应该使用T [i-2] [k] [0]代替T [i-1] [k] [0] 。其他所有内容保持不变，并且新的重复关系是

```
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])
```

这是O（n）时间和O（1）空间解：

```java
public int maxProfit(int[] prices) {
    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);
        T_ik0_pre = T_ik0_old;
    }
    
    return T_ik0;
}
```

#### 案例六：k=+Infinity但是有手续费

再次，此案例与案例II非常相似，因为它们具有相同的k值，只是现在需要对递归关系进行一些修改以解决“交易费用”的要求。案例二的原始递归关系由下式给出

```
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])
```

由于现在我们需要为每笔交易支付一定的费用（表示为费用），因此应该将第i天买卖股票后的利润减去该金额，因此新的重复关系将是

```
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee)
```

或者

```
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee)
T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])
```

请注意，关于何时扣除费用，我们有两种选择。这是因为（如上所述）每笔交易的特点是两个动作成对出现-买卖。可以在我们购买股票（对应于第一组方程式）时或当我们出售它（对应于第二组方程式）时支付费用。以下是对应于这两个选项的O（n）时间和O（1）空间解，其中对于第二个解，我们需要注意可能的溢出。

```java
public int maxProfit(int[] prices, int fee) {
    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        int T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);
    }
        
    return T_ik0;
}
```

或者

```java
public int maxProfit(int[] prices, int fee) {
    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;
    
    for (int price : prices) {
        long T_ik0_old = T_ik0;
        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);
        T_ik1 = Math.max(T_ik1, T_ik0_old - price);
    }
        
    return (int)T_ik0;
}
```

