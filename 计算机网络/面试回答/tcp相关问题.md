1. tcp和upd的区别

   大概10点左右

   | TCP                                                    | UDP                                         |
   | ------------------------------------------------------ | ------------------------------------------- |
   | TCP是面向链接协议                                      | UDP是无连接协议                             |
   | TCP在发送数据前先需要建立连接，然后再发送数据          | UDP是无需建立连接就可以直接发送大量数据     |
   | TCP会按照特定顺序重新排列数据包                        | UDP数据包没有固定顺序，所有数据包都相互独立 |
   | TCP传输的速度比较慢                                    | UDP传输速度快                               |
   | TCP头部是20个字节                                      | UDP头部字节只要8个字节                      |
   | TCP是重量级的，在发送任何用户数据之前，TCP需要三次握手 | UDP是轻量级的，没有跟踪连接，消息排序等     |
   | TCP会进行错误校验，并能够错误恢复                      | UDP也有错误检查，但会丢弃错误数据包         |
   | TCP有发送确认                                          | UDP没有                                     |
   | TCP有握手协议                                          | UDP没有握手协议                             |
   | TCP是可靠的                                            | UDP不可靠                                   |

2. TCP的三次握手

   SYN是同步序列，是TCP建立连接时使用的握手信号，ACK作为应答，表示自己的数据已经确认接收无误。

   三次握手的步骤以及各自的状态：

   1. 开始的时候客户端和服务器都是close，然后服务器开始进入listen状态
   2. 客户端发送（SYN=1，seq=x）的请求报文，也就是首部同步序列号为1，序列号为x的报文给服务器，发送后客户端进入SYN-SENT（同步已发送状态）状态
   3. 服务器接收到客户端发送的请求报文之后，然后服务器发送（SYN=1，ACK=1，seq=y，ack=x+1）的确认报文给客户端，也就是首部同步序列号为1，ACK=1，确认序列号为x+1，序列号为y的报文给客户端，服务器进入SYN-RCVD（同步收到）状态，
   4. 客户端接收都服务器发的确认报文之后，然后客户端发送（ACK=1，seq=x+1，ack=y+1）的包给服务器，也就是首部ACK=1，确认序列号为y+1，序列号为x+1的包给服务器，客户端进入ESTABLISHED（已建立连接）状态。注意这个报文段可以携带数据
   5. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

   三次握手的作用：

   * Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
   * Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
   * Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

   为什么TCP嗨需要最后发送一次确认？

   主要是防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

   如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

   当第一次握手SYN丢包，怎么办？

   当第一次握手丢包后，会进行超时重传，每次超时时间 RTO 是**指数（翻倍）上涨的**（1，2，4，8，16），当超过最大重传次数后，客户端不再发送 SYN 包。重传次数由tcp_syn_retries决定

   当第二次握手SYN丢包，怎么办？

   当 TCP 第二次握手 SYN、ACK 包丢了后，客户端 SYN 包会发生超时重传，服务端 SYN、ACK 也会发生超时重传。

   客户端 SYN 包超时重传的最大次数，是由 tcp_syn_retries 决定的，默认值是 5 次；服务端 SYN、ACK 包时重传的最大次数，是由 tcp_synack_retries 决定的，默认值是 5 次。

   当第三次握手丢包，怎么办？

   在建立 TCP 连接时，如果第三次握手的 ACK，服务端无法收到，则服务端就会短暂处于 `SYN_RECV` 状态，而客户端会处于 `ESTABLISHED` 状态。由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过 `tcp_synack_retries` 值（默认值 5 次）后，服务端就会断开 TCP 连接。客户端有两种可能性：1.在两个小时内如果没有任何连接相关的活动，则会启动保活机制，每隔75秒发送一个探测报文，如果9次没有无响应，认为对方是不可达的，从而中断本次的连接。

   2.如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 `tcp_retries2` 值（默认值 15 次）后，客户端就会断开 TCP 连接。

   

3. tcp的四次挥手

   1. 最开始服务器和客户端都是处于ESTABLISHED（已建立连接）状态
   2. 客户端进程发出连接释放报文，并且停止发送数据。客户端发送报文(FIN=1,seq=u),也就是首部FIN=1，序列号为u的报文给服务器，其中u等于前面已经传送过来的数据的最后一个字节的序号加1，此时客户端进入客户端进入FIN-WAIT-1（终止等待1）状态。
   3. 服务器接收到报文，然后服务器发送（ACK=1，ack=u+1，seq=v），也就是首部ACK=1，确认确认序列号u+1，序列号v的报文给客户端，这时服务器进入close-wait（关闭等待）状态，
   4. 客户端收到确认请求的报文之后，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
   5. 服务器将最后的数据发送完毕，就向客户端发送连接释放报文（FIN=1，ACK=1，seq=w，ack=u+1），也就是首部FIN=1，ACK=1，确认序列号为u+1的报文给客户端，此时服务器进入LAST-ACK（最后确认）状态，等待客户端确认
   6. 客户端收到服务器的连接释放报文后，发送确认报文（ACK=1，seq=u+1，ack=w+1），也就是首部ACK=1，序列号为u+1，确认序列号为w+1的报文给服务器，此时客户端进入了TIME-WAIT（时间等待）状态，此时TCP连接还未断开，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
   7. 服务器收到客户端的确认报文后，立即进入CLOSED状态。

   为什么客户端需要等待2MSL的时间？

   1. 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
   2. 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。 客户端发送完最后一个确认报文后，在这个2MSL时间中，可以使得所有报文都从网络中消失

   为啥关闭需要四次挥手？

   建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
   而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

   如果已经连接的客户端出问题怎么办？

   TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

4. tcp的重传机制
   
   * 超时重传，在发送数据的时候设置一个定时器，当超过指定时间后，如果没有收到对方的ACK确认报文，就会重发该数据，也就是我们常说的**超时重传**。需要注意的是超时重传的时间RTO是一个动态变化的值，在RFC6289中有建议的公式进行计算
   * 快速重传，它**不以时间为驱动，而是以数据驱动重传**。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。重传一个ACK，还是重传所有是一个值得商讨的问题
   * SACK方法，在tcp头部加一个SACK的东西，它可以将缓存的地图信息发送给发送方，这样发送方就知道那些数据收到了，那些数据没有收到，就可以只重传丢失的数据
   * Duplicate SACK，其实主要是使用**SACK 来告诉「发送方」有哪些数据被重复接收了。**主要体现在SACK的数据小于ACK的数据。
   * 使用SACK的好处：
     * 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;如果是包丢了则SACK大于ACK，接收方包丢了是SACK小于ACK
     * 可以知道是不是「发送方」的数据包被网络延迟了;
   
5. tcp中的滑动窗口
   
   tcp中为了很好的解决传输问题，引入了窗口这个概念，窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。窗口大小为无需等待确认应答，而继续发送数据的大小。
   
   窗口大小由哪一方决定？
   
   tcp头部中有一个较window的字段，这个字段是接收方告诉发送方自己还有多少缓冲区可以接收数据。**于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**窗口大小由哪一方决定？
   
   
   
   发送方的滑动窗口
   
   发送方的滑动窗口可以根据情况分为四个部分，已经发送并且已经确认、已发送未确认、未发送但是在接收方范围之内，未发送但是总大小超过接收方范围。在tcp当中采用三个指针，两个绝对指针，一个相对指针，来跟踪这四个传输类。
   
   * `SND.UNA`：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号
   * `SND.NXT`：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号
   * 第三个指针它需要 `SND.UNA` 指针加上 `SND.WND` 大小的偏移量
   
   
   
   接收方的滑动窗口
   
   接收方的窗口分为三个部分，第一部分是已经成功接收并确认、第二部分是未收到的数据但可以接收，但三部分是未收到数据并且不可以接收的数据。使用了两个指针来跟踪这三块区域。
   
   * `RCV.NXT`：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号
   * `RCV.NXT` 指针加上 `RCV.WND` 大小的偏移量，就可以指向#4的第一个字节了
   
   
   
   接收窗口和发送窗口大小相等吗？
   
   并不是完全相等，接收窗口的大小是**约等于**发送窗口的大小的。因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。
   
6. 流量控制
   
   发送方不能无脑发送数据给接收方，需要考虑接收方的处理能力，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会**被操作系统调整**。当进程没有办法及时读取到缓冲区的内容时，也会对缓冲区造成影响，会动态的改变窗口大小，如果窗口都收缩为 0 了，也就是发生了窗口关闭。除此之外当操作系统资源非常紧张的时候，操作系统可能会直接减少接收缓存区大小，这时可能造成一些严重的问题
   
   
   
   为了解决窗口关闭的问题，TCP 为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。**如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；如果接收窗口不是 0，那么死锁的局面就可以被打破了。
   
   
   
   解决了糊涂窗口综合症，糊涂窗口综合症指的是如果接收方太忙，当接收方腾出几个字节并告诉发送方**现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**，因为`TCP + IP` 头有 `40` 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。
   
   为了解决这个问题，接收方通常采用如下策略，当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，也就阻止了发送方再发数据过来。
   
   为了解决这个问题，发送方采用了Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：
   
   * 要等到窗口大小 >= `MSS` 或是 数据大小 >= `MSS`
   * 收到之前发送数据的 `ack` 回包

7. 拥塞控制
   
   一般来说计算机网络处于一个共享的环境，因此也有可能因为其他主机之间的通讯使得网络拥堵，tcp再网络发生拥塞时会进行控制，降低发生的数据量，避免发送方的数据填满整个网络，为了在发送方调节所要发送数据量，定义了一个叫做“拥塞窗口”的概念
   
   拥塞窗口cwnd时发送方维护的一个状态变量，他会根据网络的拥塞程度动态的进行变化。前面提到的发送方窗口大小swnd和接收方窗口大小rwnd时约等于关系，但是其实swnd=min（cwnd，rwnd），拥塞窗口大小变化规则：
   
   * 只要网络中没有出现拥塞，`cwnd` 就会增大；
   * 但网络中出现了拥塞，`cwnd` 就减少；
   
   那我们要弄清楚怎么样才算出现拥塞，其实只要时发送方没有在规定时间内接收到ACK的应答报文，也就发生了超时重传，就认为网络当中出现了拥塞。
   
   拥塞控制主要有四个算法：
   
   * 慢启动。慢启动的规则：当发送方没收到一个ACK，拥塞窗口cwnd的大小就会加1。可以看出在一个RTT时间内，cwnd会进行指数增长，这样的增长会有一个阈值ssthresh的状态变量，当cwnd<ssthresh时，采用的慢启动算法，当cwnd>=ssthresh时采用的是拥塞避免算法
   * 拥塞避免算法。当cwnd大于ssthresh后采用的算法，一般来说ssthresh大小为65535个字节。拥塞避免算法的规则：每收到一个ACK应答报文，**cwnd 增加 1/cwnd**大小，这样使得在拥塞避免阶段cwnd变成了线性增长。线性增长也不会无限制增长，当出现丢包，也就是进入拥塞状态时，就会采用拥塞发送算法
   * 拥塞发生算法。拥塞发生后会进行包的重传，重传主要分成超时重传和快速重传两种，这两种重传对应的算法也是不同的。
     * 超时重传的拥塞发生算法。在这个时候sshresh 会设置为cwnd/2，而cwnd会重置为1。接着重新开始慢启动。
     * 快速重传的拥塞发生算法。当收到相同的ACK包三次，就会触发快速重传，在tcp当中认为快速重传这种情况并不严重，只是丢了一小部分，这是cwnd会设置为cwnd/2，ssthresh=cwnd，然后进入快速回复算法
   * 快速恢复算法。快速重传和快速恢复算法一般同时使用，快速恢复的规则：
     * 拥塞窗口cwnd= ssthresh + 3，因为有3个 数据包被收到了
     * 重传丢失的数据包
     * 如果再收到重复ACK，则窗口cwnd增加1
     * 如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法（说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态）
   
   
   
   
   
   
   
   