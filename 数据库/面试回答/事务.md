1. 事务的概念

   事务是逻辑上的一组操作，要么做，要么不做。通俗的说事务是满足acid特性一组操作，可以通过Commit 进行提交，也可以通过Rollback 进行回滚。

2. 事务的四大特性

   * 原子性：事务被视为不可分割的最小单元，原子性确保事务要不完成要不无效。
   * 一致性：数据库在事务执行前后都保持一致性的状态。在一致性的状态下
   * 隔离性：并发访问数据库是，一个用户的事务不会被其他事务所打扰，个并发事务之间的数据库是独立的
   * 持久性：一个事务被提交后，它对数据库中数据的改变是持久的。

   mysql是怎么实现事务的四大特性？

   * 原子性，mysql利用了Innodb的`undo log`，`undo log`名为回滚日志，记录了那些需要进行回滚的信息，当事务执行失败或者调用了rollback，导致事务进行回滚时，`undo log`信息将数据回滚到修改之前的样子

   * 一致性，从数据库层面来说，原子性、隔离性、持久性三个性质时用来保证一致性，通过这三大特性，数据库才能保证一致性。（当然还是可以从应用层面破坏一致性）

   * 持久性，mysql是通过Innodb的`redo log`进持久性。我们知道mysql是将磁盘上的数据加载到内存当中，然后在内存当中进行修改，最终再写回到内存中，但是如果在写回之前，发生故障，比如宕机，内存当中的数据可能就会发生丢失。所以会使用`redo log`解决上面的问题。当数据进行修改之后，`redo log`会记录这次操作，当数据宕机之后，就可以根据redo log中的内容恢复到数据库中，再根据`undo log`和`binlog`内容决定回滚数据还是提交数据。

   * 隔离性

     接着下面的一个问题，并发带来的问题-->事务的隔离级别以及实现

3. 并发带来的问题。

   * 脏读:一个事务A正在访问并且修改了数据，另一个事务B也进行访问，并且读取这个修改的数据,但是最终事务A没有进行提交，那么事务B读取的事务为脏数据
   * 丢失修改：事务A正在读取该数据，进行了修改，然后事务B也读取该数据，并且进行了修改，那么事务A的修改丢失，所以叫丢失修改
   * 不可重复读：在一个事务A内多次读取一个数据，然后在此期间另一个事务B也访问了该数据，并且对该数据进行了修改，导致一个事务两次读取的数据不相同，所以叫不可重复读。
   * 幻读：在一个事务A读取几行数据，接着另一个并发事务B插入或者删除了一些数据，在随后的查询当中A会发现多或者少一些记录，就跟幻觉一样，所以叫幻读

4. 事务的隔离级别

   * RU(读取未提交):最低隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读不可重复读。
   * RC(读已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是没有办法解决幻读喝不可重复读。方法是对读取的数据加共享锁，读完就释放。
   * RR(可重复读)：对同一字段多次读取的结果是一致的，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。方法是再整个事务的执行过程中都获取了被堵数据的共享锁，不进行释放。
   * SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。在事务的过程中加表级锁。

   mysql中四个隔离级别的实现：

   * 读取未提交。读不会加任何锁。而写会加排他锁，并到事务结束之后释放。
   * 读已提交。读数据时使用MVVC，写数据时，使用排它锁
   * 可重复读。

5. 